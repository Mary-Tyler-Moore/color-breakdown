{"version":3,"file":"sw.js","sources":["../src/service-worker/index.ts"],"sourcesContent":["const resources = [\n    './',\n    'index.html',\n    'css/base.css',\n    'css/desktop.css',\n    'css/new.css',\n    'css/palette.css',\n    'img/placeholder.svg',\n    'img/favicon/logo24.png',\n    'img/favicon/logo48.png',\n    'img/favicon/logo192.png',\n    'img/demo/andrew-hughes-261571-unsplash.jpg',\n    'img/demo/ever-wild-634729-unsplash.jpg',\n    'img/demo/will-turner-1244879-unsplash.jpg',\n    'js/chunk-0e059a95.js',\n    'js/db-worker.js',\n    'js/index.js',\n    'lib/node-vibrant/vibrant.js',\n    'lib/node-vibrant/worker.js',\n    'lib/pwacompat.js',\n    'lib/shimport.js',\n];\n\nconst CACHE = 'color-breakdown-HASH';\n\nexport declare var self: ServiceWorkerGlobalScope;\n\n// On install, cache some resources.\nself.addEventListener('install', event => {\n    // Ask the service worker to keep installing until the returning promise\n    // resolves.\n    event.waitUntil(precache());\n});\n\n// On activate, clean up old caches\nself.addEventListener('activate', event => {\n    event.waitUntil(clearOldCaches());\n});\n\n// On fetch, use cache but update the entry with the latest contents from the\n// server.\nself.addEventListener('fetch', event => {\n    event.respondWith(fromCache(event.request));\n});\n\n/**\n * Open a cache and use addAll() with an array of assets to add all of them to\n * the cache. Return a promise resolving when all the assets are added.\n */\nasync function precache() {\n    const cache = await caches.open(CACHE);\n    return cache.addAll(resources);\n}\n\n/**\n * Open the cache where the assets were stored and search for the requested\n * resource. Notice that in case of no matching, the promise still resolves\n * but it does with undefined as value.\n */\nasync function fromCache(request: Request) {\n    const matching = await caches.match(request);\n    if (matching) {\n        return matching;\n    }\n    try {\n        return await fetch(request);\n    } catch (err) {\n        if (new URL(request.url).hostname !== 'www.googletagmanager.com') {\n            throw new TypeError('Failed to fetch Google Analytics');\n        }\n        throw new TypeError(`Failed to fetch: ${request.url}`);\n    }\n}\n\nasync function clearOldCaches() {\n    const cacheNames = await caches.keys();\n    return Promise.all(\n        cacheNames\n            .filter(name => name !== CACHE)\n            .map(name => caches.delete(name)),\n    );\n}\n"],"names":[],"mappings":";;;IAAA,MAAM,SAAS,GAAG;QACd,IAAI;QACJ,YAAY;QACZ,cAAc;QACd,iBAAiB;QACjB,aAAa;QACb,iBAAiB;QACjB,qBAAqB;QACrB,wBAAwB;QACxB,wBAAwB;QACxB,yBAAyB;QACzB,4CAA4C;QAC5C,wCAAwC;QACxC,2CAA2C;QAC3C,sBAAsB;QACtB,iBAAiB;QACjB,aAAa;QACb,6BAA6B;QAC7B,4BAA4B;QAC5B,kBAAkB;QAClB,iBAAiB;KACpB,CAAC;IAEF,MAAM,KAAK,GAAG,0DAAsB,CAAC;IAIrC;IACA,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,KAAK;;;QAGlC,KAAK,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;IAChC,CAAC,CAAC,CAAC;IAEH;IACA,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK;QACnC,KAAK,CAAC,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;IAEH;IACA;IACA,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK;QAChC,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IAEH;;;;IAIA,eAAe,QAAQ;QACnB,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvC,OAAO,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED;;;;;IAKA,eAAe,SAAS,CAAC,OAAgB;QACrC,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAI,QAAQ,EAAE;YACV,OAAO,QAAQ,CAAC;SACnB;QACD,IAAI;YACA,OAAO,MAAM,KAAK,CAAC,OAAO,CAAC,CAAC;SAC/B;QAAC,OAAO,GAAG,EAAE;YACV,IAAI,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,QAAQ,KAAK,0BAA0B,EAAE;gBAC9D,MAAM,IAAI,SAAS,CAAC,kCAAkC,CAAC,CAAC;aAC3D;YACD,MAAM,IAAI,SAAS,CAAC,oBAAoB,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;SAC1D;IACL,CAAC;IAED,eAAe,cAAc;QACzB,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,IAAI,EAAE,CAAC;QACvC,OAAO,OAAO,CAAC,GAAG,CACd,UAAU;aACL,MAAM,CAAC,IAAI,IAAI,IAAI,KAAK,KAAK,CAAC;aAC9B,GAAG,CAAC,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CACxC,CAAC;IACN,CAAC;;;;"}