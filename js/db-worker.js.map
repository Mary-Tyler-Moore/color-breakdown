{"version":3,"file":"db-worker.js","sources":["../../node_modules/idb/build/esm/chunk.js","../../node_modules/idb/build/esm/index.js","../../src/db-worker/process-entry.ts","../../src/db-worker/examples.ts","../../src/db-worker/db.ts","../../src/revoke-object-url.ts","../../src/db-worker/handle-message.ts","../../src/db-worker/index.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return idbProxyableTypes ||\r\n        (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\r\n        IDBCursor.prototype.advance,\r\n        IDBCursor.prototype.continue,\r\n        IDBCursor.prototype.continuePrimaryKey,\r\n    ]);\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise.then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n    });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1] ?\r\n                    undefined : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store'))\r\n            return true;\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        'objectStoreNames' in IDBTransaction.prototype) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype)) {\r\n        return;\r\n    }\r\n    let method;\r\n    if (readMethods.includes(targetFuncName)) {\r\n        method = function (storeName, ...args) {\r\n            let target = this.transaction(storeName).store;\r\n            if (useIndex)\r\n                target = target.index(args.shift());\r\n            return target[targetFuncName](...args);\r\n        };\r\n    }\r\n    if (writeMethods.includes(targetFuncName)) {\r\n        method = function (storeName, ...args) {\r\n            const tx = this.transaction(storeName, 'readwrite');\r\n            tx.store[targetFuncName](...args);\r\n            return tx.done;\r\n        };\r\n    }\r\n    if (method)\r\n        cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import { HistoryEntry, PaletteEntry } from '../entry';\n\n/**\n * Convert Data URI representing an image into a blob with the same data.\n * @see https://stackoverflow.com/questions/12168909/blob-from-dataurl\n */\nexport function dataUriToBlob(dataUri: string) {\n    const [header, data] = dataUri.split(',', 2);\n\n    // separate out the mime component\n    const mimeType = header.split(':', 2)[1].split(';', 1)[0];\n    // convert base64 to raw binary data held in a string\n    const byteString = atob(data);\n\n    // write the bytes of the string to an ArrayBuffer\n    const buffer = new ArrayBuffer(byteString.length);\n    const intBuffer = new Uint8Array(buffer); // create a view into the buffer\n    for (let i = 0; i < byteString.length; i++) {\n        intBuffer[i] = byteString.charCodeAt(i);\n    }\n\n    return new Blob([buffer], { type: mimeType });\n}\n\n/**\n * Convert blob to data uri\n * @throws DOMException if error when reading\n */\nexport function blobToDataUri(blob: Blob) {\n    return new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result as string);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(blob);\n    });\n}\n\nexport function processEntry(entry: HistoryEntry): PaletteEntry;\nexport function processEntry(entry: null | undefined): null;\nexport function processEntry(\n    entry: HistoryEntry | null | undefined,\n): PaletteEntry | null;\nexport function processEntry(\n    entry: HistoryEntry | null | undefined,\n): PaletteEntry | null {\n    if (entry == null) {\n        return null;\n    }\n    const timestamp = entry.id as number;\n    const imgBlob = dataUriToBlob(entry.imgSrc);\n    return {\n        timestamp,\n        imgSrc: URL.createObjectURL(imgBlob),\n        colors: entry.colors,\n        name: entry.name || new Date(timestamp).toLocaleString(),\n    };\n}\n","import { PaletteEntry } from '../entry';\n\nconst white = '#FFFFFF';\nconst black = '#FFFFFF';\n\nconst example1: PaletteEntry = {\n    timestamp: 1,\n    imgSrc: 'img/demo/andrew-hughes-261571-unsplash.jpg',\n    name: 'Photo by Andrew Hughes on Unsplash',\n    colors: {\n        vibrant: { color: '#AE340E', textColor: white },\n        darkVibrant: { color: '#6C140C', textColor: white },\n        lightVibrant: { color: '#DACC9B', textColor: black },\n        muted: { color: '#9F805F', textColor: white },\n        darkMuted: { color: '#3B3945', textColor: white },\n        lightMuted: { color: '#DAD3B0', textColor: black },\n    },\n};\n\nconst example2: PaletteEntry = {\n    timestamp: 2,\n    imgSrc: 'img/demo/ever-wild-634729-unsplash.jpg',\n    name: 'Photo by ever wild on Unsplash',\n    colors: {\n        vibrant: { color: '#FBA409', textColor: black },\n        darkVibrant: { color: '#7C0404', textColor: white },\n        lightVibrant: { color: '#F9A250', textColor: black },\n        muted: { color: '#AC784C', textColor: white },\n        darkMuted: { color: '#8C6C44', textColor: white },\n        lightMuted: { color: '#BC987A', textColor: black },\n    },\n};\n\nconst example3: PaletteEntry = {\n    timestamp: 3,\n    imgSrc: 'img/demo/will-turner-1244879-unsplash.jpg',\n    name: 'Photo by Will Turner on Unsplash',\n    colors: {\n        vibrant: { color: '#1E8EE0', textColor: white },\n        darkVibrant: { color: '#061C2C', textColor: white },\n        lightVibrant: { color: '#8AC4EF', textColor: black },\n        muted: { color: '#777C80', textColor: white },\n        darkMuted: { color: '#253D4C', textColor: white },\n        lightMuted: { color: '#BBBCC4', textColor: black },\n    },\n};\n\nexport const examples: { [id: number]: PaletteEntry } = {\n    1: example1,\n    2: example2,\n    3: example3,\n};\n","import { DBSchema, openDB } from 'idb';\nimport { HistoryEntry, PaletteEntry } from '../entry';\nimport { revokeIfObjectUrl } from '../revoke-object-url';\nimport { blobToDataUri, processEntry } from './process-entry';\nimport { examples } from './examples';\n\ninterface ColorBreakdownDBSchema extends DBSchema {\n    history: {\n        key: number;\n        value: HistoryEntry;\n    };\n    example: {\n        key: number;\n        value: {\n            id: number;\n            hidden: true;\n        };\n    };\n}\n\nexport const dbPromise = openDB<ColorBreakdownDBSchema>('history-store', 2, {\n    upgrade(db, oldVersion) {\n        switch (oldVersion) {\n            case 0:\n                db.createObjectStore('history', { keyPath: 'id' });\n            // fall through\n            case 1:\n                db.createObjectStore('example', { keyPath: 'id' });\n            // fall through\n        }\n    },\n});\n\n/**\n * Loads a single history item for the main palette viewer\n */\nexport async function loadItemFromDB(\n    timestamp: number,\n): Promise<PaletteEntry | null> {\n    const db = await dbPromise;\n    if (timestamp < 10) {\n        const info = await db.get('example', timestamp);\n        const hidden = info != null ? info.hidden : false;\n        return hidden ? null : examples[timestamp] || null;\n    } else {\n        const item = await db.get('history', timestamp);\n        return processEntry(item);\n    }\n}\n\nexport async function openFirstItem(): Promise<PaletteEntry | null> {\n    const db = await dbPromise;\n    const tx = await db.transaction(['history', 'example']);\n\n    const historyItems = await tx.objectStore('history').getAll(undefined, 1);\n    if (historyItems.length > 0) {\n        return processEntry(historyItems[0]);\n    }\n\n    const exampleEntries = await tx.objectStore('example').getAll();\n    const hiddenExamples = new Set(\n        exampleEntries.filter(item => item.hidden).map(item => item.id),\n    );\n    const visibleExample = Object.values(examples).find(\n        example => !hiddenExamples.has(example.timestamp),\n    );\n    return visibleExample || null;\n}\n\n/**\n * Delete a history item with the given timestamp\n */\nexport async function deleteItemFromDB(timestamp: number) {\n    const db = await dbPromise;\n    if (timestamp < 10) {\n        await db.put('example', { id: timestamp, hidden: true });\n    } else {\n        await db.delete('history', timestamp);\n    }\n}\n\n/**\n * Load the history list.\n * @param callback Called on each iteration.\n */\nexport async function loadHistoryFromDB(\n    exampleCb: (id: number) => void,\n    historyCb: (entry: PaletteEntry) => void,\n) {\n    const db = await dbPromise;\n    const tx = await db.transaction(['history', 'example']);\n\n    await Promise.all([\n        tx\n            .objectStore('example')\n            .openCursor()\n            .then(async cursor => {\n                while (cursor) {\n                    if (cursor.value.hidden) {\n                        exampleCb(cursor.key);\n                    }\n                    cursor = await cursor.continue();\n                }\n            }),\n        tx\n            .objectStore('history')\n            .openCursor()\n            .then(async cursor => {\n                while (cursor) {\n                    historyCb(processEntry(cursor.value)!);\n                    cursor = await cursor.continue();\n                }\n            }),\n    ]);\n}\n\n/**\n * Save items to the database.\n * Items may have object URLs as `imgSrc` properties, and will be processed\n * into data URIs.\n */\nexport async function saveItemsToDB(\n    items: PaletteEntry[],\n): Promise<HistoryEntry[]> {\n    // Need to process entries first due to IDB restrictions\n    const entries = await Promise.all(\n        items.map(async item => {\n            const blob = await fetch(item.imgSrc).then(r => r.blob());\n            const dataUri = await blobToDataUri(blob);\n            revokeIfObjectUrl(item.imgSrc);\n            return {\n                id: item.timestamp,\n                imgSrc: dataUri,\n                colors: item.colors,\n                name: item.name,\n            };\n        }),\n    );\n\n    const db = await dbPromise;\n    const { store, done } = await db.transaction('history', 'readwrite');\n    entries.forEach(entry => store.put(entry));\n    await done;\n\n    return entries;\n}\n","/**\n * Revoke a url if it is an object url.\n */\nexport function revokeIfObjectUrl(url: string) {\n    if (new URL(url).protocol === 'blob:') {\n        URL.revokeObjectURL(url);\n    }\n}\n\n/**\n * When used as an `onload` listener for an image, this function will\n * revoke the image's source object url if it is an object url.\n */\nexport function revokeObjectUrlOnLoad(evt: Event) {\n    const img = evt.target as HTMLImageElement;\n    revokeIfObjectUrl(img.src);\n}\n","import { HistoryEntry, PaletteEntry } from '../entry';\nimport { UiAction } from '../page/handle-message';\nimport {\n    deleteItemFromDB,\n    loadHistoryFromDB,\n    loadItemFromDB,\n    openFirstItem,\n    saveItemsToDB,\n} from './db';\nimport { processEntry } from './process-entry';\n\ninterface SaveAction {\n    type: 'SAVE';\n    payload: PaletteEntry[];\n}\n\ninterface LoadAction {\n    type: 'LOAD';\n    payload: null;\n}\n\ninterface OpenAction {\n    type: 'OPEN';\n    payload: {\n        timestamp: number;\n        firstLoad: boolean;\n    };\n}\n\ninterface DeleteAction {\n    type: 'DELETE';\n    payload: {\n        timestamp: number;\n        current: boolean;\n    };\n}\n\nexport type WorkerAction = SaveAction | LoadAction | OpenAction | DeleteAction;\ntype ProcessEntryFunc = (entry: HistoryEntry) => PaletteEntry;\n\nexport async function handleMessage(\n    action: WorkerAction,\n    postMessage: (msg: UiAction) => void,\n) {\n    console.log(action.type, action.payload);\n    try {\n        switch (action.type) {\n            case 'SAVE':\n                if (action.payload.length > 0) {\n                    const entries = await saveItemsToDB(action.payload);\n                    postMessage({\n                        type: 'DISPLAY',\n                        payload: {\n                            entry: processEntry(entries[0]),\n                            firstLoad: false,\n                            updateHash: true,\n                        },\n                    });\n                    postMessage({\n                        type: 'ADD',\n                        payload: entries.map(processEntry as ProcessEntryFunc),\n                    });\n                }\n                return;\n            case 'LOAD':\n                await loadHistoryFromDB(\n                    id => postMessage({ type: 'REMOVE', payload: [id] }),\n                    entry => postMessage({ type: 'ADD', payload: [entry] }),\n                );\n                return;\n            case 'OPEN':\n                let entry: PaletteEntry | null = null;\n                if (!Number.isNaN(action.payload.timestamp)) {\n                    entry = await loadItemFromDB(action.payload.timestamp);\n                }\n                postMessage({\n                    type: 'DISPLAY',\n                    payload: {\n                        entry,\n                        firstLoad: action.payload.firstLoad,\n                        updateHash: false,\n                    },\n                });\n                return;\n            case 'DELETE':\n                if (!Number.isNaN(action.payload.timestamp)) {\n                    await deleteItemFromDB(action.payload.timestamp);\n                    postMessage({\n                        type: 'REMOVE',\n                        payload: [action.payload.timestamp],\n                    });\n                    if (action.payload.current) {\n                        const otherEntry = await openFirstItem();\n                        postMessage({\n                            type: 'DISPLAY',\n                            payload: {\n                                entry: otherEntry,\n                                firstLoad: false,\n                                updateHash: true,\n                            },\n                        });\n                    }\n                }\n                return;\n        }\n    } catch (err) {\n        postMessage({ type: 'ERROR', payload: String(err) });\n    }\n}\n","import { handleMessage } from './handle-message';\n\nexport declare var self: DedicatedWorkerGlobalScope;\n\nself.addEventListener('message', evt => handleMessage(evt.data, postMessage));\nhandleMessage({ type: 'LOAD', payload: null }, postMessage);\n"],"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","[object Object]","target","prop","receiver","IDBTransaction","get","objectStoreNames","undefined","objectStore","wrap","has","wrapFunction","func","IDBDatabase","prototype","transaction","storeNames","args","tx","call","unwrap","this","set","sort","IDBCursor","advance","continue","continuePrimaryKey","includes","apply","transformCachableValue","value","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","result","then","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","method","storeName","store","index","shift","processEntry","entry","timestamp","id","imgBlob","dataUri","header","data","split","mimeType","byteString","atob","buffer","ArrayBuffer","length","intBuffer","Uint8Array","i","charCodeAt","Blob","type","dataUriToBlob","imgSrc","URL","createObjectURL","colors","name","Date","toLocaleString","oldTraps","callback","white","black","examples","1","vibrant","color","textColor","darkVibrant","lightVibrant","muted","darkMuted","lightMuted","2","3","dbPromise","version","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","openDB","createObjectStore","keyPath","async","saveItemsToDB","items","entries","all","map","item","blob","fetch","r","reader","FileReader","onload","onerror","readAsDataURL","blobToDataUri","url","protocol","revokeObjectURL","revokeIfObjectUrl","forEach","put","handleMessage","action","postMessage","console","log","payload","firstLoad","updateHash","exampleCb","historyCb","openCursor","cursor","hidden","key","loadHistoryFromDB","Number","isNaN","info","loadItemFromDB","delete","deleteItemFromDB","current","otherEntry","historyItems","getAll","exampleEntries","hiddenExamples","Set","filter","Object","values","find","example","openFirstItem","err","String","self","evt"],"mappings":"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"}